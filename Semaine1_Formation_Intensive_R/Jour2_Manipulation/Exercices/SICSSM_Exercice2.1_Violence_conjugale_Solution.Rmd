---
title: "Exercice 2: Accès à l'information et attitudes face à la violence conjugale"
author: "Visseho Adjiwanou, PhD."
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  pdf_document: default
  word_document: default
  html_document: default
---



Dans cet exercice, vous aller travailler à partir de la base de donnée `dhs_ipv` qui a été utilisée dans cette étude :

Pierotti, Rachel. (2013). "[Increasing Rejection of Intimate Partner Violence: Evidence of Global Cultural Diffusion](http://dx.doi.org/10.1177/0003122413480363)." *American Sociological Review*, 78: 240-265. 

Il s'agit d'une base de données dont l'unité d'analyse sont les pays sur lesquels on dispose d'un certain nombre d'information. Ces informations sont présentées dans le tableau ci-dessous:

Name             Description
---------------  ---------------------------------------------------------
`beat_goesout`     Pourcentage de femmes dans chaque pays qui pensent qu'un mari est justifié de battre sa femme
                 si elle sort sans le lui dire. 
`beat_burnfood`    Pourcentage de femmes dans chaque pays qui pensent qu'un mari a                                le droit de battre sa femme
                 si elle brûle sa nourriture.  
`no_media`         Pourcentage de femmes dans chaque pays qui ont rarement accès un 
                 journal, une radio ou une télévision.
`sec_school`       Pourcentage de femmes dans chaque pays ayant un niveau d'éducation                             secondaire ou supérieur.
`year`             Année de l’enquête
`region`           Région du monde
`country`          pays


Notez qu'il existe dans ce fichier de données, deux indicateurs/variables qui mesurent les *attitudes envers la violence domestique*: `beat_goesout` et `beat_burnfood`. Ce sont ces variables que nous voulons expliquer/comprendre. On les appelle des variables dépendantes ou variables à expliquer ou des `outcomes`. Il existe également deux indicateurs/variables qui mesurent l'*accès à l'information*: `sec_school` et `no_media`. Celles-ci sont appelées des variables explicatives.

Comme toujours, il faut prévoir un premier *chunck* où vous installez vos packages, les chargez et chargez la base de données. C'est une procédure qu'il faut toujours suivre. Sachez aussi que vous devez ouvrir ce fichier RMarkDown et travailler directement dedans.


```{r, results='hide'}
#1. Effacer l'environnement

rm(list = ls())     # Permet d'éffacer l'environnement

#2. Installer de nouveaux packages dont vous avez besoin

#3. Chargez ces packaqes 
library(tidyverse)

#4. Ouvrir votre base de données
dhs <- read.csv("../Données/dhs_ipv.csv")

```

Comme vous avez pu le voir en classe, quand vous chargez Tidyverse, il charge l'ensemble des packages qui sont inclus dedans. C'est la dernière fois que je dresse la table pour vous :)


# PARTIE A: Sélection des variables et des observations

## Question 1 

Votre base de données comprend combien d'observation et combien de variables ? Soyez **concis** dans votre réponse.

### Réponse

- La fonction **dim** vous donne la taille de l'échantillon et le nombre de variables. Elle est appliquée à la base de données en entier.
- La fonction unique vous donne la liste des informations uniques sur une variable. Elle est appliquée à une variable donnée.

```{r}

dim(dhs)
unique(dhs$country)

```

- Taille échantillon: 151. Mais, plusieurs pays interviennent plus d'une fois car il s'agit de données longitudinales
- Les données concernent 65 pays

Informations additionnelles non demandées:

```{r}

summary(dhs)

```


- Nature des variables:
  - Toutes les variables sont de type quantitative (ou variable continue)
  - Variables dépendantes: Les variables qu'on cherche à expliquer. beat_burnfood et beat_goesout.
  - Variables indépendantes: Les variables qui permettent d'expliquer les variables dépendantes. sec_school et no_media.
  
- Données manquantes
  - beat_burnfood : 31
  - beat_goesout : 27
  _ sec_school : 3
  - no_media : 13
  
- Raison des variables manquantes
  - Pour les variables beat_burnfood et beat_goesout et no_media: probablement que les questions sur l'attitude de femmes sur la violence contre les femmes n'ont pas été posées au cours de cette période dans ces pays.
  - Pour sec_school, c'est plus difficile à donner les raisons des valeurs manquantes. Dans toutes les enquêtes, la question sur le niveau d'éducation est posée, spécialement dans les enquêtes EDS.
  
## Question 2

Dites le type de chaque variable de la base de données. Comment est ce que R comprend ce type de variable? Présentez l'information dans un tableau.


### Votre réponse

Variables          Type (statistique)               Type (R)
------------------ -------------------------------- ---------------------------
beat_goesout       Quantitative continue (ratio)    Numeric
beat_burnfood      Quantitative continue (ratio)    Numeric
sec_school         Quantitative continue (ratio)    Numeric
no_media           Quantitative continue (ratio)    Numeric
country            Qualitative nominale             Factor
region             Qualitative nominale             Factor
year               Quantitative discrète            Integer
                   

## Question 3

Quelle est le type de chaque variable de la base de données? Utiliser la fonction **class** pour le savoir. Maintenant, vous allez vous poser la question de savoir si la réponse que vous obtenez est réellement le type de chaque variable. 


### Votre réponse


```{r}

class(dhs$beat_burnfood)
class(dhs$beat_goesout)
class(dhs$sec_school)
class(dhs$no_media)
class(dhs$country)
class(dhs$region)
class(dhs$year)

```

Oui, le type de chaque variable est correctement exprimé par R. Mais, il n'est pas toujours le cas. Il arrive que vous changiez le type de la variable pour refléter sa vraie nature.

## Question 4

Je vous demande de créer 5 nouvelles bases de données avec les conditions suivantes. Dans chaque cas, décrivez cette base de données en terme de population et de variables.

1. **dhs1**: beat_goesout est plus grand ou égale à 14 (ceci signifie que la valeur de la variable beat_goesout est >= 14)

Vous comprenez que j'ai utilisé l'écriture du code en mode **Tidyverse**. Ce que nous voulons faire, c'est une série de créations de nouveaux fichiers de données. Pour ce faire, Nous devons indiquer le fichier de données à  partir duquel le nouveau fichier va être crée. 
- La première ligne du code indique le nom du nouveau fichier
- La deuxième ligne indique le fichier qui va être utilisé. Cette ligne est terminée par le symbole %>% qu'on appelle **pipe**. Ce symbole n'a aucune signification statistique ou mathématique. Il indique juste une succession d'opération.
- la dernière ligne donne les indications sur la manière dont vous voulez créer le fichier de la **première ligne**.

```{r}

dhs1 <- 
  dhs %>% 
  filter(beat_goesout >= 14)

# vérification
min(dhs1$beat_goesout)

```

2. **dhs2**: beat_goesout est plus grand que 13 et beat_burnfood est plus petit que 22

```{r}
dhs2 <-
  dhs %>% 
  filter(beat_goesout > 13 & beat_burnfood < 22)

# Verification
min(dhs2$beat_goesout)
max(dhs2$beat_burnfood)

```

3. **dhs3**: sec_school plus grand que 22 et beat_goesout plus grand que 25


```{r}

dhs3 <-
  dhs %>% 
  filter(sec_school > 22 & beat_goesout > 25)

```

4. **dhs4**: comprend les pays d'Afrique sub-Saharienne dont beat_goesout est plus grand que 18 et sec_school est plus grand que 10

```{r}

dhs4 <-
  dhs %>% 
  filter(region == "Sub-Saharan Africa" & beat_goesout > 18 & sec_school > 10)

```

5. **dhs5**: beat_goesout plus petit que 15 ou beat_goesout plus grand que 22

```{r}
dhs5 <-
  dhs %>% 
  filter(beat_goesout < 15 | beat_goesout > 22)   # Symbole du ou |

```

### Votre réponse 

Voir en dessous de chaque question. 
  

## Question 5

Créer des bases de données remplissant les conditions suivantes:

1. **dhs6**: comprend les pays dont le nom commence par c (bonus)

En statistique "traditionnelle", nous ne travaillons pas avec des caractères. Mais, comme je vous l'ai dit, de plus en plus de données viennent sous la forme de texte. On ne peut pas traiter cela avec ce que nous avons fait avec les fichiers 1 à 5. Il faut utiliser des fonctions qui fonctionnent sur des caractères. Le package **stringr** de Tidyverse vous permet de faire cela. Voici un **fichier de trichérie (sheetcheat)** dont vous pouvez vous référer aisément: http://edrub.in/CheatSheets/cheatSheetStringr.pdf. Vous trouverez des exemples d'utilisation ici: https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html


```{r}

dhs6 <-
  dhs %>% 
  filter(str_starts(country, 'C'))

# Autre manière
 dhs6 <- 
   dhs %>% 
   filter(str_detect(country,"^C"))

```

2. **dhs7**: comprend les pays dont le nom finit par i

```{r}

dhs7 <-
  dhs %>% 
  filter(str_ends(country, 'i'))

```

3. **dhs8**: comprend tous les pays pour lequel `sec_school` est plus grand que la valeur moyenne de `sec_school`

```{r}

dhs8 <-
  dhs %>% 
  filter(sec_school > mean(sec_school, na.rm = TRUE))

```

La difficulté ici est que la fonction **mean** qui calcule la moyenne ne fonctionne pas si la variable contient des données manquantes. Donc, l'option **na.rm** à l'intérieur de la parenthèse enlève les valeurs manquantes de la base de données avant de calculer la moyenne. na.rm signifie : **remove na**.

4. **dhs9**: sélectionner les pays qui ont au moins deux années d'observation.

```{r}

# dhs9 : créer d'abord dhs91 intermédiaire

dhs91 <-
  dhs %>% 
  group_by(country) %>% 
  count(country) %>% 
  filter(n >=2) 

dhs9 <- inner_join(dhs, dhs91)


      
dhs_9 <-
  dhs %>% 
  group_by(country) %>% 
  mutate(nombre = n()) %>% 
  filter(nombre >= 2)


## Autre manière de faire

dhs9 <- dhs

pays <- dhs9 %>%
  group_by(country) %>%
  mutate(x = 1) %>%
  summarize(y = sum(x)) %>%
  filter(y > 1) %>%
  select(-y)

pays <- c(pays)
pays <- unlist(pays)
pays

dhs9 <- dhs9 %>%
  filter(country %in% pays)

```

5. **dhs10**: comprend uniquement les données de la dernière année d'enquête de chaque pays. 

```{r}

dhs10 <-
  dhs %>%
  group_by(country) %>% 
   filter(year == max(year, na.rm = TRUE))

```

### Votre réponse 

Voir en dessous de chaque question. 


# Partie B: Création de variables


## Question 1

Quand on crée de nouvelles variables, la règle demande d'ajouter **toujours** cette nouvelle variable dans la base de donnée qu'on a utilisée pour la créer.
Dans la base de données **dhs**, créer les variables suivantes:

1. **Pays_riche** qui est `TRUE` si sec_school est plus grand que 20 et no_media plus petit que 5 et `FALSE` dans le cas contraire
2. **beat_goesout_3** qui rempli les conditions suivantes:
  - elle prend la valeur **1** si beat_goesout est <=10
  - elle prend la valeur **2** si beat_goesout est >10 et <= 20
  - elle prend la valeur **3** si beat_goesout > 20


### Votre réponse 

Créer une nouvelle variable signifie que celle-ci doit se trouver dans le fichier qui a servi à sa création dans la très grande majorité des cas. La création de variables se fait avec la fonction mutate. Si vous voulez créer des variables catégorielles (dites encore factorielles), c'est à dire des variables qualitatives (nominales ou ordinales), vous devez utiliser soir la fonction **if_else** (si la nouvelle variable a seulement deux catégories - dichotomique ou binaire) ou la fonction **case_when** dans les autres cas. Rien ne vous empêche d'utiliser **case_when** pour des variables dichotomiques.

Ainsi le code ci-dessous signifie:

- Première ligne: le fichier qui va contenir la nouvelle variable;
- Deuxième ligne: le fichier que vous utiliser pour créer la nouvelle variable, dont identique à la première ligne;
- Dernière ligne: comprend trois partie:
  - mutate : pour dire que vous créer une nouvelle variable
  - pays_riche: le nom de la nouvelle variable
  - if_else : la condition que vous utilisez pour créer la nouvelle variable.

```{r}
# 1

dhs <- 
  dhs %>% 
  mutate(pays_riche = if_else(sec_school > 20 & no_media < 5, TRUE, FALSE))

class(dhs$pays_riche)

# 2

dhs <- 
  dhs %>% 
  mutate(beat_goesout_3 = factor(case_when(
    beat_goesout <= 10 ~ 1,
    beat_goesout > 10 & beat_goesout <= 20 ~ 2,
    beat_goesout > 20 ~ 3), labels = c("un", "deux", "trois"))
  )

class(dhs$beat_goesout_3)

```

## Question 2 

Sur la base des valeurs de la variable `beat_burnfood`, créer une nouvelles variable **factorielle** `beat_burnfood_cat` qui regroupe les observations en quatre catégories:

1. **Très moderne**, pays où les valeurs de `beat_burnfood` sont inférieures à 5%;
2. **Moderne**, pays où les valeurs de `beat_burnfood` sont supérieures à 5% mais inférieures à 10%;
3. **Traditionnelle**, pays où les valeurs de `beat_burnfood` sont supérieures à 10% mais inférieures à 20%;
4. **Très traditionnelle**, pays où les valeurs de `beat_burnfood` sont supérieures à 20%.


### Réponse 2

```{r}

dhs <-
  dhs %>% 
  mutate(beat_burnfood_cat = case_when(
    beat_burnfood < 5 ~ "Très moderne",
    beat_burnfood > 5 & beat_burnfood < 10 ~ "Moderne",
    beat_burnfood >10 & beat_burnfood < 20 ~ "Traditionnelle",
    beat_burnfood > 20 ~ "Très traditionnelle"
  ))

class(dhs$beat_burnfood_cat)

```

Il vous indique que la classe de cette nouvelle variable est **caractère**. Vous voulez une variable factorielle. Alors, il faut précéder le code précédent de factor comme suit:

```{r}

dhs <-
  dhs %>% 
  mutate(beat_burnfood_cat = factor(case_when(
    beat_burnfood < 5 ~ "Très moderne",
    beat_burnfood > 5 & beat_burnfood < 10 ~ "Moderne",
    beat_burnfood >10 & beat_burnfood < 20 ~ "Traditionnelle",
    beat_burnfood > 20 ~ "Très traditionnelle"
  )))

class(dhs$beat_burnfood_cat)

```

Mais si vous avez déjà crée le variable ou si le variable existe déjà, vous pouvez changer son type de cette manière:

```{r}

dhs <-
  dhs %>% 
  mutate(beat_burnfood_cat = as_factor(beat_burnfood_cat))

class(dhs$beat_burnfood_cat)

```


# Partie C: Statistique univariée



## Question 1

Calculer les paramètres de **position** de la variable `beat-goesout`

Les fonctions de création des paramètres de position et de dispersion se trouvent déjà dans base R. Il s'agit de min, max, mean, median, quantile, var, IQR, etc. Donc, tidyverse va se baser sur cela pour créer de manière élégante ces statistiques. Juste vous rappeler que la fonction **mode** de base R ne donne pas le mode d'une variable. C'est pourquoi, on a crée une autre fonction ici pour créer le mode. Je vous expliquerai plus tard en classe. 

Rappelez-vous, les paramètres de positions ou de dispersion nous donne des informations synthétiques sur les variables. Par exemple l'âge moyen prend tous les âges des individus et nous donne leur moyenne. Donc, on s'attend à retrouver une seule valeur en calculant les paramètres de position et de dispersion. C'est pourquoi, ces paramètres ne vont jamais se trouver dans le fichier de données initiales comme dans le cas de la création de nouvelles variables.

```{r}

getmode <- function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}

# Paramètres de position et de dispersion de la variable beat-goesout
position_goesout <- 
  dhs %>% 
  summarise(v_min = min(beat_goesout, na.rm = TRUE), 
            v_max = max(beat_goesout, na.rm = TRUE), 
            v_moyen = mean(beat_goesout, na.rm = TRUE), 
            v_median = median(beat_goesout, na.rm = TRUE), 
            v_Q1 = quantile(beat_goesout, prob = 0.25, na.rm = TRUE), 
            v_Q3 = quantile(beat_goesout, prob = 0.75, na.rm = TRUE),
            V_mode = getmode(na.omit(beat_goesout))) %>% 
  mutate(Variable = "beat_goesout", region = "Ensemble")

position_goesout  

position_goesout$v_moyen

```

## Question 4

Faite le même calcul selon les régions d'études. Commentez les résultats. 
PS. Vous ne devez ajouter qu'une seule ligne de commande à votre code de la question 4 pour répondre à la question.


La fonction **group_by** est très puissant. Elle permet de repliquer le même exercice sur différents groupes. C'est une "arme puissante"" que vous devez avoir dans votre "boite à codes".

```{r}

position_goesout_region <- 
  dhs %>% 
  group_by(region) %>% 
  summarise(v_min = min(beat_goesout, na.rm = TRUE), 
            v_max = max(beat_goesout, na.rm = TRUE), 
            v_moyen = mean(beat_goesout, na.rm = TRUE), 
            v_median = median(beat_goesout, na.rm = TRUE), 
            v_Q1 = quantile(beat_goesout, prob = 0.25, na.rm = TRUE), 
            v_Q3 = quantile(beat_goesout, prob = 0.75, na.rm = TRUE),
            V_mode = getmode(na.omit(beat_burnfood))) %>% 
  mutate(Variable = "beat_goesout")

position_goesout_region  



```

## Question 5

Calculer les paramètres de **dispersion** de la variable `beat-goesout`

```{r}

dispersion_goesout <-
  dhs %>% 
  summarise(v_etendue = max(beat_goesout, na.rm = TRUE) - min(beat_goesout, na.rm = TRUE), 
            v_ei = IQR(beat_goesout, na.rm = TRUE), 
            v_ei1 = position_goesout$v_Q3 - position_goesout$v_Q1, 
            v_variance = var(beat_goesout, na.rm = TRUE), 
            v_et = sd(beat_goesout, na.rm = TRUE), 
            v_et1 = sqrt(v_variance)) %>% 
  mutate(Variable = "beat_goesout", region = "Ensemble") 

dispersion_goesout

```

## Question 6

Faite le même calcul selon les régions d'études. Commentez les résultats. 
PS. Vous ne devez ajouter qu'une seule ligne de commande à votre code de la question 4 pour répondre à la question.

```{r}


dispersion_goesout_region <-
  dhs %>% 
  group_by(region) %>% 
  summarise(v_etendue = max(beat_goesout, na.rm = TRUE) - min(beat_goesout, na.rm = TRUE), 
            v_ei = IQR(beat_goesout, na.rm = TRUE), 
            v_ei1 = position_goesout$v_Q3 - position_goesout$v_Q1, 
            v_variance = var(beat_goesout, na.rm = TRUE), 
            v_et = sd(beat_goesout, na.rm = TRUE), 
            v_et1 = sqrt(v_variance)) %>% 
  mutate(Variable = "beat_goesout")

dispersion_goesout_region

```


- Une manière d'interpréter les résultats. ici, fait avec la variable beat_burnfood.

- On observe que la moyenne de la variable `beat_burnfood` est plus élevée en Afrique sub-Saharienne que dans les autres régions du monde. En moyenne dans les pays d'Afrique sub-Saharienne, 21% (20,85) des femmes estiment qu'un mari a le droit de battre sa femme si elle brûle la nourriture. Cette moyenne est de 12% au Moyen Orient, 3,7% en Amérique Latine et 8,3% en Asie. La moyenne étant souvent affectée par les valeurs aberrantes, on lui préfère la médiane. 

- Dans la moitié des pays d'Afrique sub-Saharienne, la proportion des femmes qui estime qu'un mari a le droit de battre sa femme quand elle brûle la nourriture est inférieure à 19% (dans l'autre moitié, la proportion est supérieure à cette valeur). Il est intéressant de remarquer que la moyenne et la médiane de la région Afrique sub-Saharienne sont proches alors que celles du Moyen Orient sont éloignées l'une de l'autre. Ceci peut être une indication de valeur aberrante dans cette région.

- Si on met ces résultats en relation avec par exemple la variable `sec-school`, on observe une inversion des caractéristiques de position. En Afrique sub-Saharienne, en moyenne, la proportion des femmes qui ont le niveau secondaire ou plus est de 17% alors qu'elle montre à 28% en Asie, 31% en Amérique Latine et 46% au Moyen-Orient. 

- Le classement des régions sur la base de la moyenne selon la variable `beat_burnfood` (ordre décroissant) et le classement selon `sec_school` (ordre croissant) donne :
  - Afrique sub-Saharienne          Moyen-Orient
  - Moyen-Orient                    Amérique Latine
  - Asie                            Asie
  - Amérique latine                 Afrique-sub-Saharienne

- cela montre que la relation n'est pas totalement linéaire. Des facteurs autres que l'éducation permettent donc d'expliquer l'attitude des femmes sur la violence conjugale. 



# Partie D: Statistiques bivariées

- Tableau synthétisant l'information sur l'association entre variables

![](/Users/visseho/OneDrive - UQAM/Cours/Images_cours/Tableau_association.png)


## Question 1

Y'a-t-il une association entre la variable `beat_goesout` et `sec_school`? quel type d'analyse vous permet de répondre à cette question?

### réponse

Les deux variables étant de type quantitative continues, on peut calculer le coefficient de corrélation de Pearson pour révéler l'existence d'une association. On peut aussi visualiser cette association avec ggplot.

- Corrélation de Pearson

```{r}

cor.test(dhs$beat_goesout, dhs$sec_school)

```

- Visualisation

```{r}

ggplot(dhs) +
  geom_point(aes(x = sec_school, y = beat_goesout))
```

- Distinguer les différents pays

```{r}

ggplot(dhs) +
  geom_point(aes(x = sec_school, y = beat_goesout, color = region))

```

- Indiquer le nom des pays

```{r}

ggplot(dhs) +
  geom_label(aes(x = sec_school, y = beat_goesout, label = country))

```

Présenter la droite de régression


```{r}

ggplot(dhs) +
  geom_point(aes(x = sec_school, y = beat_goesout, color = region)) +
  geom_smooth(aes(x = sec_school, y = beat_goesout, color = region), method = "lm", se = F)

```


## Question 2

Y-a-t'il une association entre la variable `beat_goesout` et `region`? quel type d'analyse vous permet de répondre à cette question?


### Réponse

On est dans le cas de l'association entre une variable dépendante de type quantitative continue et une variable indépendant de type qualitative. On fera l'analyse de la variance pour révéler cette association. On regardera si la moyenne dans les groupes diffèrent entre eux. Dans le cas de graphique, on fera un diagramme de quartiles ou boîte à moustache. 

- Analyse de la variance

```{r}

analyse_variance <- aov(beat_goesout ~ region, data = dhs)
summary(analyse_variance)

```

L'analyse de la variance utilise la statistique F pour mesurer l'association entre une variable dépendante quantitative et une variable indépendante qualitative. 

- Boîte à moustaches

```{r}

ggplot(dhs) +
  geom_boxplot(aes(x = region, y = beat_goesout))

```


# Partie E: Création de votre propre base de données

## Question 1

Vous vous demandez d'où provient cette base de données. Et bien comme je vous l'ai dit, cela provient des enquêtes démographiques et de santé. Utiliser Statcompiler pour créer votre base de données sur le sujet qui vous intéresse. Le site est https://www.statcompiler.com/en/.

1. Sélectionner l'ensemble des pays
2. Choisissez les deux variables suivantes:
  - **Physical or sexual violence committed by husband/partner**
  - **Women with secondary or higher education**
  - Quelle est la variable dépendante? Quelle est la variable indépendante?
3. Exportez les données dans une base de données (voir Export en haut du site, choisissez database).
4. Ouvrez cette base de données dans R (Quelle est le problème avec votre procédure?)
5. Sélectionner les données du Kenya.


### Votre réponse 

```{r}

```





----------------------------------------------------------- **BON EXERCICE** ---------------------------------------------------------
